<html>
<head>
<title>MyHeap.java</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.ln { color: rgb(0,0,0); font-weight: normal; font-style: normal; }
.s0 { color: rgb(204,120,50); }
.s1 { color: rgb(169,183,198); }
.s2 { color: rgb(98,151,85); font-style: italic; }
.s3 { color: rgb(128,128,128); }
.s4 { color: rgb(104,151,187); }
.s5 { color: rgb(106,135,89); }
</style>
</head>
<BODY BGCOLOR="#2b2b2b">
<TABLE CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#C0C0C0" >
<TR><TD><CENTER>
<FONT FACE="Arial, Helvetica" COLOR="#000000">
MyHeap.java</FONT>
</center></TD></TR></TABLE>
<pre>
<span class="s0">package </span><span class="s1">fu.alp3</span><span class="s0">;</span><span class="s1"> 
 
</span><span class="s0">import </span><span class="s1">sun.reflect.generics.reflectiveObjects.NotImplementedException</span><span class="s0">;</span><span class="s1"> 
 
</span><span class="s0">import </span><span class="s1">java.util.EmptyStackException</span><span class="s0">;</span><span class="s1"> 
</span><span class="s0">import </span><span class="s1">java.util.Iterator</span><span class="s0">;</span><span class="s1"> 
 
</span><span class="s2">/** 
 * Created by Boyan on 11/30/2016. 
 */</span><span class="s1"> 
 
</span><span class="s0">public class </span><span class="s1">MyHeap { 
 
    </span><span class="s0">private int</span><span class="s1">[] heap</span><span class="s0">;</span><span class="s1"> 
    </span><span class="s0">private int </span><span class="s1">lastElem</span><span class="s0">; </span><span class="s3">//requested variable name, is lastElemIndex really</span><span class="s1"> 
 
    </span><span class="s0">public </span><span class="s1">MyHeap(</span><span class="s0">int</span><span class="s1">[] elements) { 
 
        </span><span class="s0">this</span><span class="s1">.heap = elements.clone()</span><span class="s0">; </span><span class="s3">//clone the array so no unexpected behavior occurs</span><span class="s1"> 
        </span><span class="s0">this</span><span class="s1">.lastElem = elements.length - </span><span class="s4">1</span><span class="s0">;</span><span class="s1"> 
        </span><span class="s0">this</span><span class="s1">.constructHeapBottomUp()</span><span class="s0">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">public </span><span class="s1">MyHeap(</span><span class="s0">int </span><span class="s1">arrayLength) { 
 
        </span><span class="s0">this</span><span class="s1">.heap = </span><span class="s0">new int</span><span class="s1">[arrayLength]</span><span class="s0">;</span><span class="s1"> 
        </span><span class="s0">this</span><span class="s1">.lastElem = -</span><span class="s4">1</span><span class="s0">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">public int </span><span class="s1">getLastElem() { 
 
        </span><span class="s0">return this</span><span class="s1">.lastElem</span><span class="s0">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">public void </span><span class="s1">insert(</span><span class="s0">int </span><span class="s1">newElement) { 
 
        </span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.isFull()) { 
 
            </span><span class="s0">throw new </span><span class="s1">OutOfMemoryError(</span><span class="s5">&quot;The heap is already full. No further elements can be added!&quot;</span><span class="s1">)</span><span class="s0">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">this</span><span class="s1">.lastElem++</span><span class="s0">;</span><span class="s1"> 
        </span><span class="s0">this</span><span class="s1">.heap[lastElem] = newElement</span><span class="s0">;</span><span class="s1"> 
        </span><span class="s0">this</span><span class="s1">.bubbleUp(lastElem)</span><span class="s0">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">public int </span><span class="s1">deleteMin() { 
 
        </span><span class="s3">/* 
         * Summary: returns the smallest element (the root element of the heap), puts the last element as root, 
         *          reorders the heap and marks the new last element 
          * */</span><span class="s1"> 
 
        </span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.isEmpty()) { 
 
            </span><span class="s0">throw new </span><span class="s1">RuntimeException(</span><span class="s5">&quot;The heap is already empty. You cannot remove further elements from it!&quot;</span><span class="s1">)</span><span class="s0">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">int </span><span class="s1">minElement = </span><span class="s0">this</span><span class="s1">.heap[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">;</span><span class="s1"> 
 
        </span><span class="s0">this</span><span class="s1">.heap[</span><span class="s4">0</span><span class="s1">] = </span><span class="s0">this</span><span class="s1">.heap[</span><span class="s0">this</span><span class="s1">.lastElem]</span><span class="s0">;</span><span class="s1"> 
        </span><span class="s0">this</span><span class="s1">.lastElem--</span><span class="s0">;</span><span class="s1"> 
        </span><span class="s0">this</span><span class="s1">.bubbleDown(</span><span class="s4">0</span><span class="s1">)</span><span class="s0">;</span><span class="s1"> 
 
        </span><span class="s0">return  </span><span class="s1">minElement</span><span class="s0">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">public void </span><span class="s1">updateKey(</span><span class="s0">int </span><span class="s1">index</span><span class="s0">, int </span><span class="s1">key) { 
 
        </span><span class="s0">int </span><span class="s1">previousKey = </span><span class="s0">this</span><span class="s1">.heap[index]</span><span class="s0">;</span><span class="s1"> 
        </span><span class="s0">this</span><span class="s1">.heap[index] = key</span><span class="s0">;</span><span class="s1"> 
 
        </span><span class="s0">if</span><span class="s1">(previousKey &lt; key) { 
 
            bubbleDown(index)</span><span class="s0">;</span><span class="s1"> 
        } 
        </span><span class="s0">else </span><span class="s1">{ 
 
            bubbleUp(index)</span><span class="s0">;</span><span class="s1"> 
        } 
    } 
 
    </span><span class="s0">public boolean </span><span class="s1">isFull() { 
 
        </span><span class="s0">return this</span><span class="s1">.getLastElem() == heap.length - </span><span class="s4">1</span><span class="s0">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">public boolean </span><span class="s1">isEmpty() { 
 
        </span><span class="s0">return this</span><span class="s1">.lastElem == -</span><span class="s4">1</span><span class="s0">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">public int</span><span class="s1">[] getHeapAsArray() { 
 
        </span><span class="s0">return this</span><span class="s1">.heap.clone()</span><span class="s0">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">public void </span><span class="s1">printHeapAsArray() { 
 
        System.out.print(</span><span class="s5">&quot;Heap: &quot;</span><span class="s1">)</span><span class="s0">;</span><span class="s1"> 
        printArray(</span><span class="s0">this</span><span class="s1">.getHeapAsArray())</span><span class="s0">;</span><span class="s1"> 
    } 
 
    </span><span class="s3">//---------------------------------------Helper Methods----------------------------------------</span><span class="s1"> 
 
    </span><span class="s0">private void </span><span class="s1">constructHeapBottomUp() { 
 
        </span><span class="s3">// Construct heap structure</span><span class="s1"> 
 
        </span><span class="s0">int </span><span class="s1">lastInternalNode = </span><span class="s0">this</span><span class="s1">.getLastInternalNode()</span><span class="s0">;</span><span class="s1"> 
 
        </span><span class="s0">for </span><span class="s1">(</span><span class="s0">int </span><span class="s1">i = lastInternalNode</span><span class="s0">; </span><span class="s1">i &gt;= </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i--) { 
 
            </span><span class="s0">this</span><span class="s1">.bubbleDown(i)</span><span class="s0">;</span><span class="s1"> 
        } 
    } 
 
    </span><span class="s0">private void </span><span class="s1">xorSwapInHeap(</span><span class="s0">int </span><span class="s1">idxA</span><span class="s0">, int </span><span class="s1">idxB) { 
 
        </span><span class="s3">/* 
        * Basic swap algorithm using bitwise XOR operations. If you don't know it I suggest a quick google search. 
        * */</span><span class="s1"> 
 
        </span><span class="s0">this</span><span class="s1">.heap[idxA] ^= </span><span class="s0">this</span><span class="s1">.heap[idxB]</span><span class="s0">;</span><span class="s1"> 
        </span><span class="s0">this</span><span class="s1">.heap[idxB] ^= </span><span class="s0">this</span><span class="s1">.heap[idxA]</span><span class="s0">;</span><span class="s1"> 
        </span><span class="s0">this</span><span class="s1">.heap[idxA] ^= </span><span class="s0">this</span><span class="s1">.heap[idxB]</span><span class="s0">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">private void </span><span class="s1">bubbleUp(</span><span class="s0">int </span><span class="s1">index) { 
 
        </span><span class="s0">int </span><span class="s1">currentIndex = index</span><span class="s0">;</span><span class="s1"> 
        </span><span class="s0">int </span><span class="s1">parentNodeIndex</span><span class="s0">;</span><span class="s1"> 
 
        </span><span class="s0">while</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.hasParentNode(currentIndex)) { 
 
            parentNodeIndex = </span><span class="s0">this</span><span class="s1">.getParentNodeIndex(currentIndex)</span><span class="s0">;</span><span class="s1"> 
 
            </span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.heap[currentIndex] &lt; </span><span class="s0">this</span><span class="s1">.heap[parentNodeIndex]) { 
 
                </span><span class="s0">this</span><span class="s1">.xorSwapInHeap(currentIndex</span><span class="s0">, </span><span class="s1">parentNodeIndex)</span><span class="s0">;</span><span class="s1"> 
                currentIndex = parentNodeIndex</span><span class="s0">;</span><span class="s1"> 
            } 
            </span><span class="s0">else </span><span class="s1">{ 
 
                </span><span class="s3">//No need to go further up the tree if there was not swap needed on the last step</span><span class="s1"> 
                </span><span class="s0">break;</span><span class="s1"> 
            } 
        } 
    } 
 
    </span><span class="s0">private void </span><span class="s1">bubbleDown(</span><span class="s0">int </span><span class="s1">index) { 
 
        </span><span class="s0">int </span><span class="s1">currentIndex = index</span><span class="s0">;</span><span class="s1"> 
        </span><span class="s0">int </span><span class="s1">leftChildIndex</span><span class="s0">;</span><span class="s1"> 
        </span><span class="s0">int </span><span class="s1">rightChildIndex</span><span class="s0">;</span><span class="s1"> 
 
        </span><span class="s0">int </span><span class="s1">minIndex</span><span class="s0">;</span><span class="s1"> 
 
        </span><span class="s0">while</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.hasLeftChild(currentIndex)) { 
 
            </span><span class="s3">// Because of the definition of a heap if a right child exists, a left child will exist as well</span><span class="s1"> 
 
            leftChildIndex = </span><span class="s0">this</span><span class="s1">.getLeftChild(currentIndex)</span><span class="s0">;</span><span class="s1"> 
            minIndex = leftChildIndex</span><span class="s0">;</span><span class="s1"> 
 
            </span><span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.hasRightChild(currentIndex)) { 
 
                rightChildIndex = </span><span class="s0">this</span><span class="s1">.getRightChild(currentIndex)</span><span class="s0">;</span><span class="s1"> 
 
                minIndex = </span><span class="s0">this</span><span class="s1">.heap[leftChildIndex] &lt; </span><span class="s0">this</span><span class="s1">.heap[rightChildIndex] ? leftChildIndex : rightChildIndex</span><span class="s0">;</span><span class="s1"> 
            } 
 
            </span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.heap[minIndex] &lt; </span><span class="s0">this</span><span class="s1">.heap[currentIndex]) { 
 
                </span><span class="s0">this</span><span class="s1">.xorSwapInHeap(minIndex</span><span class="s0">, </span><span class="s1">currentIndex)</span><span class="s0">;</span><span class="s1"> 
                currentIndex = minIndex</span><span class="s0">;</span><span class="s1"> 
            } 
            </span><span class="s0">else </span><span class="s1">{ 
 
                </span><span class="s3">//no need to continue if both children are bigger than the root</span><span class="s1"> 
                </span><span class="s0">break;</span><span class="s1"> 
            } 
 
        } 
 
    } 
 
    </span><span class="s0">private boolean </span><span class="s1">hasParentNode(</span><span class="s0">int </span><span class="s1">index) { 
 
        </span><span class="s0">return </span><span class="s1">index &gt; </span><span class="s4">0</span><span class="s0">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">private int </span><span class="s1">getParentNodeIndex(</span><span class="s0">int </span><span class="s1">index) { 
 
        </span><span class="s0">return </span><span class="s1">(</span><span class="s0">int</span><span class="s1">) Math.floor( (index - </span><span class="s4">1</span><span class="s1">) / </span><span class="s4">2</span><span class="s1">)</span><span class="s0">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">private boolean </span><span class="s1">hasLeftChild(</span><span class="s0">int </span><span class="s1">index) { 
 
        </span><span class="s0">int </span><span class="s1">leftChildIndex = </span><span class="s0">this</span><span class="s1">.getLeftChild(index)</span><span class="s0">;</span><span class="s1"> 
        </span><span class="s0">boolean </span><span class="s1">isOutOfBounds = leftChildIndex &gt; </span><span class="s0">this</span><span class="s1">.getLastElem()</span><span class="s0">;</span><span class="s1"> 
 
        </span><span class="s0">return </span><span class="s1">!isOutOfBounds</span><span class="s0">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">private boolean </span><span class="s1">hasRightChild(</span><span class="s0">int </span><span class="s1">index) { 
 
        </span><span class="s0">int </span><span class="s1">rightChildIndex = </span><span class="s0">this</span><span class="s1">.getRightChild(index)</span><span class="s0">;</span><span class="s1"> 
        </span><span class="s0">boolean </span><span class="s1">isOutOfBounds = rightChildIndex &gt; </span><span class="s0">this</span><span class="s1">.getLastElem()</span><span class="s0">;</span><span class="s1"> 
 
        </span><span class="s0">return </span><span class="s1">!isOutOfBounds</span><span class="s0">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">private int </span><span class="s1">getLeftChild(</span><span class="s0">int </span><span class="s1">index) { 
 
        </span><span class="s0">return </span><span class="s1">index*</span><span class="s4">2 </span><span class="s1">+ </span><span class="s4">1</span><span class="s0">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">private int </span><span class="s1">getRightChild(</span><span class="s0">int </span><span class="s1">index) { 
 
        </span><span class="s0">return </span><span class="s1">index*</span><span class="s4">2 </span><span class="s1">+ </span><span class="s4">2</span><span class="s0">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">private int </span><span class="s1">getLastInternalNode() { 
 
        </span><span class="s0">return </span><span class="s1">(</span><span class="s0">int</span><span class="s1">)Math.floor(</span><span class="s0">this</span><span class="s1">.heap.length / </span><span class="s4">2</span><span class="s1">)</span><span class="s0">;</span><span class="s1"> 
    } 
 
    </span><span class="s3">//---------------------------------------Test Methods------------------------------------------</span><span class="s1"> 
 
    </span><span class="s0">public static int</span><span class="s1">[] sort(</span><span class="s0">int</span><span class="s1">[] array) { 
 
        MyHeap heap = </span><span class="s0">new </span><span class="s1">MyHeap(array)</span><span class="s0">;</span><span class="s1"> 
        </span><span class="s0">int</span><span class="s1">[] outputArray = </span><span class="s0">new int</span><span class="s1">[array.length]</span><span class="s0">;</span><span class="s1"> 
 
        </span><span class="s0">for</span><span class="s1">(</span><span class="s0">int </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; outputArray.length</span><span class="s0">; </span><span class="s1">i++) { 
 
            outputArray[i] = heap.deleteMin()</span><span class="s0">;</span><span class="s1"> 
        } 
 
        </span><span class="s0">return </span><span class="s1">outputArray</span><span class="s0">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">public static void </span><span class="s1">printArray(</span><span class="s0">int</span><span class="s1">[] arr) { 
 
        System.out.print(</span><span class="s5">&quot;[&quot;</span><span class="s1">)</span><span class="s0">;</span><span class="s1"> 
        </span><span class="s0">for</span><span class="s1">(</span><span class="s0">int </span><span class="s1">i = </span><span class="s4">0</span><span class="s0">; </span><span class="s1">i &lt; arr.length</span><span class="s0">; </span><span class="s1">i++) { 
 
            System.out.print(arr[i] + (i == arr.length - </span><span class="s4">1 </span><span class="s1">? </span><span class="s5">&quot;&quot; </span><span class="s1">: </span><span class="s5">&quot;, &quot;</span><span class="s1">))</span><span class="s0">;</span><span class="s1"> 
        } 
        System.out.println(</span><span class="s5">&quot;]&quot;</span><span class="s1">)</span><span class="s0">;</span><span class="s1"> 
    } 
 
    </span><span class="s0">public static void </span><span class="s1">main(String[] args) { 
 
        </span><span class="s0">int</span><span class="s1">[] numbers = {</span><span class="s4">4</span><span class="s0">,</span><span class="s4">2</span><span class="s0">,</span><span class="s4">6</span><span class="s0">,</span><span class="s4">1</span><span class="s0">,</span><span class="s4">9</span><span class="s0">,</span><span class="s4">7</span><span class="s1">}</span><span class="s0">;</span><span class="s1"> 
        MyHeap heap = </span><span class="s0">new </span><span class="s1">MyHeap(numbers)</span><span class="s0">;</span><span class="s1"> 
 
        System.out.print(</span><span class="s5">&quot;Numbers: &quot;</span><span class="s1">)</span><span class="s0">;</span><span class="s1"> 
        printArray(numbers)</span><span class="s0">;</span><span class="s1"> 
        System.out.print(</span><span class="s5">&quot;sort(numbers): &quot;</span><span class="s1">)</span><span class="s0">;</span><span class="s1"> 
        printArray(sort(numbers))</span><span class="s0">;</span><span class="s1"> 
 
 
        heap.printHeapAsArray()</span><span class="s0">;</span><span class="s1"> 
        System.out.println(</span><span class="s5">&quot;heap.updateKey(3, 0)&quot;</span><span class="s1">)</span><span class="s0">;</span><span class="s1"> 
        heap.updateKey(</span><span class="s4">3</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">;</span><span class="s1"> 
        heap.printHeapAsArray()</span><span class="s0">;</span><span class="s1"> 
 
        System.out.println(</span><span class="s5">&quot;heap.deleteMin(): &quot; </span><span class="s1">+ heap.deleteMin())</span><span class="s0">;</span><span class="s1"> 
        heap.printHeapAsArray()</span><span class="s0">;</span><span class="s1"> 
 
        System.out.println(</span><span class="s5">&quot;heap.insert(3)&quot;</span><span class="s1">)</span><span class="s0">;</span><span class="s1"> 
        heap.insert(</span><span class="s4">3</span><span class="s1">)</span><span class="s0">;</span><span class="s1"> 
        heap.printHeapAsArray()</span><span class="s0">;</span><span class="s1"> 
 
    } 
} 
</span></pre>
</body>
</html>